class Tetromino {
    field TetrominoFactory factory;
    field int screenOffset; // offset to screen playground.
    field int maxSize; // 4 by 4 square.
    field int row, col;
    field int debugFlag;

    field Array piece;
    field int pieceNumber;
    field bool rotated;

     //TODO - to be remove debug
    field int randomIndex;

    constructor Tetromino new(TetrominoFactory tetrominoFactory) {
        let factory = tetrominoFactory;

        let screenOffset = 10;
        let row = 0;        // row: [0-15]
        let col = 0;        // col: [0-9]
        let maxSize = 4;    // 4 by 4: [0-3] 

        do generate();
        return this;
    }

    method void setDebugFlag(int flag) {
        let debugFlag = flag;
        return;
    }

    method int getMaxSize() {
        return maxSize;
    }

    // must run generate first!
    method void debugDumpPiece() {
        var int i, j, column, value;
        
        let column = 10;
        let i = 0;
        let j = 0;
        do Output.moveCursor(6, column);
        do Utilities.displayLabel("Current:");
        do Output.println();
        do Output.moveCursor(7, column);
        do factory.debugDumpPiece(piece);
        return;
    }

    method void debugDumpPieceLocation() {
        do Utilities.debugDisplayIntValue("row", row);
        do Utilities.debugDisplayIntValue("col", col);
        return;
    }

    method Array getCurrentPiece() {
        return piece;
    }

    method int getRow() {
        return row;
    }

    method int getCol() {
        return col;
    }

    method int getPieceValue(int pieceRow, int pieceCol) {
        var Array value;

        let value = piece[pieceRow];
        return value[pieceCol];
    }

    // Return the height of the block.
    method int getHeight() {
        return (getPieceBottomRowIndex() - getPieceTopRowIndex() + 1);
    }

    method int getWidth() {
        return (getPieceRightEdgeIndex() - getPieceLeftEdgeIndex() + 1);
    }

    method int getPieceRightEdgeColIndex() {
        var int pieceColIndex,
                pieceRowIndex;
        var Array rowValue;

        let pieceColIndex = maxSize - 1;
        while (pieceColIndex > -1) {
            let pieceRowIndex = 0;
            //let rowValue = piece[pieceRowIndex];
            //if (debugFlag = 7) {
                
            //}
            while (pieceRowIndex < maxSize) {
                let rowValue = piece[pieceRowIndex];
                //do Utilities.displayArrayValues(rowValue, maxSize);
                if (rowValue[pieceColIndex] = 1) {
                    return pieceColIndex;
                }
                let pieceRowIndex = pieceRowIndex + 1;
            }
            let pieceColIndex = pieceColIndex - 1;
        }
        return pieceColIndex;
    }

    method int getPieceLeftEdgeIndex() {
        var int pieceLeftEdgeIndex,
                rowIndex,
                val1, val2, val3, val4;
        var Array rowArray1, rowArray2, rowArray3, rowArray4;

        let rowIndex = 0;
        let pieceLeftEdgeIndex = 0;
        
        // get all 4 row Arrays, then look at each col start at 0.
        while (pieceLeftEdgeIndex < maxSize) {
            let rowArray1 = piece[rowIndex];
            let rowArray2 = piece[rowIndex + 1];
            let rowArray3 = piece[rowIndex + 2];
            let rowArray4 = piece[rowIndex + 3];
            let val1 = rowArray1[pieceLeftEdgeIndex];
            let val2 = rowArray2[pieceLeftEdgeIndex];
            let val3 = rowArray3[pieceLeftEdgeIndex];
            let val4 = rowArray4[pieceLeftEdgeIndex];

            if (((val1 = 1) | (val2 = 1)) | 
                ((val3 = 1) | (val4 = 1))) {
                    return pieceLeftEdgeIndex;
            }
            let pieceLeftEdgeIndex = pieceLeftEdgeIndex + 1;
        } // while
        return -1;
    }

    method int getPieceRightEdgeIndex() {
        var int pieceRightEdgeIndex,
                rowIndex,
                val1, val2, val3, val4;
        var Array rowArray1, rowArray2, rowArray3, rowArray4;

        let rowIndex = 0;
        let pieceRightEdgeIndex = maxSize-1;
        
        while (pieceRightEdgeIndex > -1) {
            let rowArray1 = piece[rowIndex];
            let rowArray2 = piece[rowIndex + 1];
            let rowArray3 = piece[rowIndex + 2];
            let rowArray4 = piece[rowIndex + 3];
            let val1 = rowArray1[pieceRightEdgeIndex];
            let val2 = rowArray2[pieceRightEdgeIndex];
            let val3 = rowArray3[pieceRightEdgeIndex];
            let val4 = rowArray4[pieceRightEdgeIndex];

            if (((val1 = 1) | (val2 = 1)) | 
                ((val3 = 1) | (val4 = 1))) {
                    return pieceRightEdgeIndex;
            }
            let pieceRightEdgeIndex = pieceRightEdgeIndex - 1;
        } // while
        return -1;
    }

    // return the top index value of the piece has block
    // possible value 0-3
    method int getPieceTopRowIndex() {
        var int pieceTopIndex,
                val1, val2, val3, val4;
        var Array rowValue;

        let pieceTopIndex = 0;
        while (pieceTopIndex < maxSize) {
            let rowValue = piece[pieceTopIndex];
            let val1 = rowValue[0];
            let val2 = rowValue[1];
            let val3 = rowValue[2];
            let val4 = rowValue[3];

            if (((val1 = 1) | (val2 = 1)) | 
                ((val3 = 1) | (val4 = 1))) {
                    return pieceTopIndex;
            }
            let pieceTopIndex = pieceTopIndex + 1;
        }
        return -1; //error - the piece has no block!
    }

    method int getPieceBottomRowIndex() {
        var int pieceBottom,
            val1, val2, val3, val4;
        var Array rowValue;

        let pieceBottom = maxSize - 1; 
        while (pieceBottom > -1) {
            let rowValue = piece[pieceBottom];
            let val1 = rowValue[0];
            let val2 = rowValue[1];
            let val3 = rowValue[2];
            let val4 = rowValue[3];
            
            if (((val1 = 1) | (val2 = 1)) | 
                ((val3 = 1) | (val4 = 1))) {
                    return pieceBottom;
                }
            let pieceBottom = pieceBottom - 1;
        } // while
        return -1;
    }

    // return the piece configation.
    method int getPieceConfig(int rowIndex, int colIndex) {
        var Array rowValue;
        let rowValue = Array.new(4);
        let rowValue = piece[rowIndex];
        return rowValue[colIndex];
    }

    method void setPiece(int pieceNo) {
        var Array rowArray;
        
        //TODO : better code?
        let rowArray = piece[0];
        do rowArray.dispose();
        let rowArray = piece[1];
        do rowArray.dispose();
        let rowArray = piece[2];
        do rowArray.dispose();
        let rowArray = piece[3];
        do rowArray.dispose();

        do piece.dispose();
        let piece = factory.getTetromino(pieceNo);
        let pieceNumber = pieceNo;
        let rotated = false;
        return;
    }

    method void generate() {
        //TODO: randomize
        if (randomIndex > 5) {
            let randomIndex = 0;
        } else {
            let randomIndex = randomIndex + 1;
        }
        let piece = factory.getTetromino(randomIndex);
        let rotated = false;
        let pieceNumber = randomIndex;
        let row = -1;
        let col = 0;
        return;
    }

    method void moveLeft() {
        do erasePiece();
        let col = col - 1;
        do drawPiece();
        return;
    }

    method void moveRight() {
        do erasePiece();
        let col = col + 1;
        do drawPiece();
        return;
    }

    method void rotateLeft() {
        var int rowIndex, colIndex,
                i,
                value;
        var Array destRowArray, srcRowArray, rotatedPieceArray;
        
        do erasePiece();
        let rotatedPieceArray = Utilities.initializeTwoDimensionArray(maxSize);
        let colIndex = 0;
        while (colIndex < maxSize) {
            let rowIndex = (maxSize - 1);
            let i = 0;

            while (rowIndex > -1) {
                let destRowArray = rotatedPieceArray[rowIndex];
                let srcRowArray = piece[colIndex];
                let destRowArray[colIndex] = srcRowArray[i];
                let rowIndex = rowIndex - 1;
                let i = i + 1;
            }
            let colIndex = colIndex + 1;
        }
        // copy rotatedArray to piece.
        do Utilities.copyMatrix(rotatedPieceArray, piece, maxSize);
        //zzzz
        //TODO better code?
        let srcRowArray = rotatedPieceArray[0];
        do srcRowArray.dispose();
        let srcRowArray = rotatedPieceArray[1];
        do srcRowArray.dispose();
        let srcRowArray = rotatedPieceArray[2];
        do srcRowArray.dispose();
        let srcRowArray = rotatedPieceArray[3];
        do srcRowArray.dispose();
        do rotatedPieceArray.dispose();
        
        if (~(pieceNumber = 1)) {
            do adjustRotation();
        }
        do drawPiece();
        return;
    }

    method void rotateRight() {
        var int rowIndex,
                destColIndex,
                destRowIndex,
                sourceIndex;
        var Array destMatrixArray,
                  destRowArray,
                  srcRowArray;

        do erasePiece();
        let destMatrixArray = Utilities.initializeTwoDimensionArray(maxSize);
        let rowIndex = 0;
        let destColIndex = maxSize - 1;
        let sourceIndex = 0;

        while (rowIndex < maxSize) {
            let srcRowArray = piece[rowIndex];
            let sourceIndex = 0;
            while (sourceIndex < maxSize) {
                let srcRowArray = piece[rowIndex];
                let destRowArray = destMatrixArray[sourceIndex];
                let destRowArray[destColIndex] = srcRowArray[sourceIndex];
                let sourceIndex = sourceIndex + 1;
            }
            let destColIndex = destColIndex - 1;
            let rowIndex = rowIndex + 1;
        }

        do Utilities.copyMatrix(destMatrixArray, piece, maxSize);
        if (~(pieceNumber = 1)) {
            do adjustRotation();
        }
        do drawPiece();
        // release memory
        let destRowArray = destMatrixArray[0];
        do destRowArray.dispose();
        let destRowArray = destMatrixArray[1];
        do destRowArray.dispose();
        let destRowArray = destMatrixArray[2];
        do destRowArray.dispose();
        let destRowArray = destMatrixArray[3];
        do destRowArray.dispose();
        return;
    }

    method void adjustRotation() {
        var int width,
                height,
                rightEdge,
                adjustment;

        let width = getWidth();
        let height = getHeight();
        if (rotated) {
            // adjust center rotation for I block.
            if (row < 9) {
                let row = row + 1;
                if ((row + height - 1) > 15) {
                    // adjust so bottom touch the edge.
                    let row = 15 - width + 1;
                }
            }
            if (col > 0) {
                let col = col - 1;
                let rightEdge = col + width - 1;
                if (rightEdge > 9) {
                    // adjust to touch the edge.
                    let col = 9 - width + 1;
                }
            }
            let rotated = false;
        }
        else {
            // adjust center rotation for I block.
            if (row > 0) {
                let row = row - 1;
            }
            if (col < 9) {
                let col = col + 1;
            }
            let rotated = true;
        }
        return;
    }

    method void drop() {
        do erasePiece();
        let row = row + 1;
        do drawPiece();
        return;
    }

    method void erasePiece() {
        do erase(row, col);
        return;
    }

    method void drawPiece() {
        do draw(row, col);
        return;
    }

    method void setRow(int rowNumber) {
        let row = rowNumber;
        return;
    }

    method void setCol(int colNumber) {
        let col = colNumber;
        return;
    }

    /**
     *
     **/
    method void dropTo(int rowIndex) {
        do erase(row, col);
        let row = rowIndex;
        do draw(row, col);
        return;
    }

    method void erase(int row, int col) {
        var int i, j, x, y, 
            mostLeftIndex,
            offset,
            rowIndex;
        var Array value;
        var boolean found;

        let mostLeftIndex = getPieceLeftEdgeIndex();
        let i = 0;
        let rowIndex = 0;
        let y = (row * 512);
        let x = col + screenOffset;
        let found = false;
        if (mostLeftIndex > 0) {
            // O block shift left by 1.
            // Z block no need.
            let offset = mostLeftIndex;
        }
        
        // start right from the row that has block.
        // so the piece is drawn from first line properly.
        while (i < maxSize) {
            let j = mostLeftIndex;
            let value = piece[i];
            while (j < maxSize) {
                if (value[j] = 1) {
                    let found = true;
                    do Graphics.eraseBlock(y + (rowIndex * 512) + x + j - offset);
                }
                let j = j + 1; 
            }
            let i = i + 1;
            if (found) {
                let rowIndex = rowIndex + 1;
            }
        }
        return;
    }

    method void draw(int row, int col) {
        var int i, j, x, y, 
            rowIndex,
            offset,
            mostLeftIndex;
        var Array value;
        var boolean found;

        let mostLeftIndex = getPieceLeftEdgeIndex();
        let i = 0;
        let rowIndex = 0;
        let y = (row * 512);
        let x = col + screenOffset;
        let found = false;
        if (mostLeftIndex > 0) {
            // O block shift left by 1.
            // Z block no need.
            let offset = mostLeftIndex;
        }
        // start right from the row that has block.
        // so the piece is drawn from first line properly.
        while (i < maxSize) {
            let j = mostLeftIndex;
            let value = piece[i];
            while (j < maxSize) {
                if (value[j] = 1) {
                    let found = true;
                    do Graphics.drawBlock(y + (rowIndex * 512) + x + j - offset);
                }
                let j = j + 1; 
            }
            let i = i + 1;
            if (found) {
                let rowIndex = rowIndex + 1;
            }
        }
        return;
    }

    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }
}